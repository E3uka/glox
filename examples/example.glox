/* Examples of valid glox syntax (should parse) */

/*
multiline 
comments
*/

/* declarations */
const old_dude: f64 = 28;   // typed immutable declaration
const location := "London"; // inferred immutable declaration
changeme := "password";     // inferred mutable declaration
lies: bool = false;         // typed mutable declaration

/* quick maths (correct precedence parsing) */
grouping := 1 / (3 + 2);
maths := 9 + 12 / 3 * 5;

/* blocks and scope */
outer := "hello";
{
	innner := " world";
	{
		outer += inner;
	}
	/* branch statements (soon) */
	break;
	return x / y + z;
};

/* function syntax */
create_habit :: (cue, craving, response, reward) -> string {
	println("I can see clear-ly now");
	reward++;
	result := craving(response(cue)); // nested function calls
	return result;
}

/* structs & selections */
Connection :: struct {
	address: string;
	online:  string;
	count:   f64;
}

Connection.address;
Connection.add_user(user123);
Connection.count += 1;

/* pointer reference and dereference */
value := "some location";
where := &value;
there := *where;

/*
TODO: ArrayType, FuncType, IFaceExpr, FnExpr (for first class functions)
TODO: Branch Statements (IfStmt, ForStmt, WhileStmt)

TODO: end semicolon error messages
TODO: chore: character start locations for error messages
*/
